"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var adapter_1 = require("../adapters/adapter");
var context_1 = __importDefault(require("../common/context"));
var Schema = /** @class */ (function () {
    function Schema(schema) {
        var _this = this;
        var context = context_1.default.getInstance();
        this.schema = schema;
        this.types = new Map();
        this.mutations = new Map();
        this.queries = new Map();
        this.schema.types.forEach(function (t) { return _this.types.set(t.name, t); });
        this.getType(context.adapter.getRootQueryName()).fields.forEach(function (f) {
            return _this.queries.set(f.name, f);
        });
        this.getType(context.adapter.getRootMutationName()).fields.forEach(function (f) {
            return _this.mutations.set(f.name, f);
        });
    }
    Schema.prototype.determineQueryMode = function () {
        var _this = this;
        var connection = null;
        this.queries.forEach(function (query) {
            var typeName = Schema.getTypeNameOfField(query);
            if (typeName.endsWith("TypeConnection")) {
                connection = _this.getType(typeName);
                return false; // break
            }
            return true;
        });
        /* istanbul ignore next */
        if (!connection) {
            throw new Error("Can't determine the connection mode due to the fact that here are no connection types in the schema. Please set the connectionMode via Vuex-ORM-GraphQL options!");
        }
        if (connection.fields.find(function (f) { return f.name === "nodes"; })) {
            return adapter_1.ConnectionMode.NODES;
        }
        else if (connection.fields.find(function (f) { return f.name === "edges"; })) {
            return adapter_1.ConnectionMode.EDGES;
        }
        else {
            return adapter_1.ConnectionMode.PLAIN;
        }
    };
    Schema.prototype.getType = function (name, allowNull) {
        if (allowNull === void 0) { allowNull = false; }
        name = context_1.default.getInstance().adapter.prepareSchemaTypeName(name);
        var type = this.types.get(name);
        if (!allowNull && !type) {
            throw new Error("Couldn't find Type of name " + name + " in the GraphQL Schema.");
        }
        return type || null;
    };
    Schema.prototype.getMutation = function (name, allowNull) {
        if (allowNull === void 0) { allowNull = false; }
        var mutation = this.mutations.get(name);
        /* istanbul ignore next */
        if (!allowNull && !mutation) {
            throw new Error("Couldn't find Mutation of name " + name + " in the GraphQL Schema.");
        }
        return mutation || null;
    };
    Schema.prototype.getQuery = function (name, allowNull) {
        if (allowNull === void 0) { allowNull = false; }
        var query = this.queries.get(name);
        /* istanbul ignore next */
        if (!allowNull && !query) {
            throw new Error("Couldn't find Query of name " + name + " in the GraphQL Schema.");
        }
        return query || null;
    };
    Schema.returnsConnection = function (field) {
        return Schema.getTypeNameOfField(field).endsWith("TypeConnection");
    };
    Schema.getRealType = function (type) {
        if (type.kind === "NON_NULL") {
            return this.getRealType(type.ofType);
        }
        else {
            return type;
        }
    };
    Schema.getTypeNameOfField = function (field) {
        var type = this.getRealType(field.type);
        if (type.kind === "LIST") {
            while (!type.name)
                type = type.ofType;
            return "[" + type.name + "]";
        }
        else {
            while (!type.name)
                type = type.ofType;
            /* istanbul ignore next */
            if (!type.name)
                throw new Error("Can't find type name for field " + field.name);
            return type.name;
        }
    };
    return Schema;
}());
exports.default = Schema;
//# sourceMappingURL=schema.js.map