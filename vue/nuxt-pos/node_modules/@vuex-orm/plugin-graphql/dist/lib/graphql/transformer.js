"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var model_1 = __importDefault(require("../orm/model"));
var context_1 = __importDefault(require("../common/context"));
var utils_1 = require("../support/utils");
var adapter_1 = require("../adapters/adapter");
/**
 * This class provides methods to transform incoming data from GraphQL in to a format Vuex-ORM understands and
 * vice versa.
 */
var Transformer = /** @class */ (function () {
    function Transformer() {
    }
    /**
     * Transforms outgoing data. Use for variables param.
     *
     * @param {Model} model Base model of the mutation/query
     * @param {Data} data Data to transform
     * @param {boolean} read Tells if this is a write or a read action. read is fetch, write is push and persist.
     * @param {Array<String>} whitelist of fields
     * @param {Map<string, Array<string>>} outgoingRecords List of record IDs that are already added to the
     *                                                     outgoing data in order to detect recursion.
     * @param {boolean} recursiveCall Tells if it's a recursive call.
     * @returns {Data}
     */
    Transformer.transformOutgoingData = function (model, data, read, whitelist, outgoingRecords, recursiveCall) {
        var _this = this;
        var context = context_1.default.getInstance();
        var relations = model.getRelations();
        var returnValue = {};
        if (outgoingRecords === undefined)
            outgoingRecords = new Map();
        if (recursiveCall === undefined)
            recursiveCall = false;
        Object.keys(data).forEach(function (key) {
            var value = data[key];
            var isRelation = model.getRelations().has(key);
            var isRecursion = false;
            if (value instanceof Array) {
                isRecursion = isRelation && _this.isRecursion(outgoingRecords, value[0]);
            }
            else {
                isRecursion = isRelation && _this.isRecursion(outgoingRecords, value);
            }
            // shouldIncludeOutgoingField and the read param is tricky. In the initial call of this method
            // we want to include any relation, so we have to make sure it's false. In the recursive calls
            // it should be true when we transform the outgoing data for fetch (and false for the others)
            if (!isRecursion &&
                _this.shouldIncludeOutgoingField(recursiveCall && read, key, value, model, whitelist)) {
                var relatedModel = model_1.default.getRelatedModel(relations.get(key));
                if (value instanceof Array) {
                    // Either this is a hasMany field or a .attr() field which contains an array.
                    var arrayModel_1 = context.getModel(utils_1.singularize(key), true);
                    if (arrayModel_1) {
                        _this.addRecordForRecursionDetection(outgoingRecords, value[0]);
                        returnValue[key] = value.map(function (v) {
                            return _this.transformOutgoingData(arrayModel_1 || model, v, read, undefined, outgoingRecords, true);
                        });
                    }
                    else {
                        // Simple field, not a relation
                        returnValue[key] = value;
                    }
                }
                else if (typeof value === "object" && value.$id !== undefined) {
                    if (!relatedModel) {
                        relatedModel = context.getModel(value.$self().entity);
                    }
                    _this.addRecordForRecursionDetection(outgoingRecords, value);
                    // Value is a record, transform that too
                    returnValue[key] = _this.transformOutgoingData(relatedModel, value, read, undefined, outgoingRecords, true);
                }
                else {
                    // In any other case just let the value be what ever it is
                    returnValue[key] = value;
                }
            }
        });
        return returnValue;
    };
    /**
     * Transforms a set of incoming data to the format vuex-orm requires.
     *
     * @param {Data | Array<Data>} data
     * @param model
     * @param mutation required to transform something like `disableUserAddress` to the actual model name.
     * @param {boolean} recursiveCall
     * @returns {Data}
     */
    Transformer.transformIncomingData = function (data, model, mutation, recursiveCall) {
        var _this = this;
        if (mutation === void 0) { mutation = false; }
        if (recursiveCall === void 0) { recursiveCall = false; }
        var result = {};
        var context = context_1.default.getInstance();
        if (!recursiveCall) {
            context.logger.group("Transforming incoming data");
            context.logger.log("Raw data:", data);
        }
        if (Array.isArray(data)) {
            result = data.map(function (d) { return _this.transformIncomingData(d, model, mutation, true); });
        }
        else {
            Object.keys(data).forEach(function (key) {
                if (data[key] !== undefined && data[key] !== null && key in data) {
                    if (utils_1.isPlainObject(data[key])) {
                        var localModel = context.getModel(key, true) || model;
                        if (data[key].nodes && context.connectionMode === adapter_1.ConnectionMode.NODES) {
                            result[utils_1.pluralize(key)] = _this.transformIncomingData(data[key].nodes, localModel, mutation, true);
                        }
                        else if (data[key].edges && context.connectionMode === adapter_1.ConnectionMode.EDGES) {
                            result[utils_1.pluralize(key)] = _this.transformIncomingData(data[key].edges, localModel, mutation, true);
                        }
                        else if (data["node"] && context.connectionMode === adapter_1.ConnectionMode.EDGES) {
                            result = _this.transformIncomingData(data["node"], localModel, mutation, true);
                        }
                        else {
                            var newKey = key;
                            if (mutation && !recursiveCall) {
                                newKey = data[key].nodes ? localModel.pluralName : localModel.singularName;
                                newKey = utils_1.downcaseFirstLetter(newKey);
                            }
                            result[newKey] = _this.transformIncomingData(data[key], localModel, mutation, true);
                        }
                    }
                    else if (model_1.default.isFieldNumber(model.fields.get(key))) {
                        result[key] = parseFloat(data[key]);
                    }
                    else if (key.endsWith("Type") && model.isTypeFieldOfPolymorphicRelation(key)) {
                        result[key] = utils_1.pluralize(utils_1.downcaseFirstLetter(data[key]));
                    }
                    else {
                        result[key] = data[key];
                    }
                }
            });
        }
        if (!recursiveCall) {
            context.logger.log("Transformed data:", result);
            context.logger.groupEnd();
        }
        else {
            result["$isPersisted"] = true;
        }
        // Make sure this is really a plain JS object. We had some issues in testing here.
        return utils_1.clone(result);
    };
    /**
     * Tells if a field should be included in the outgoing data.
     * @param {boolean} forFilter Tells whether a filter is constructed or not.
     * @param {string} fieldName Name of the field to check.
     * @param {any} value Value of the field.
     * @param {Model} model Model class which contains the field.
     * @param {Array<String>|undefined} whitelist Contains a list of fields which should always be included.
     * @returns {boolean}
     */
    Transformer.shouldIncludeOutgoingField = function (forFilter, fieldName, value, model, whitelist) {
        // Always add fields on the whitelist.
        if (whitelist && whitelist.includes(fieldName))
            return true;
        // Ignore internal fields
        if (fieldName.startsWith("$"))
            return false;
        // Ignore empty fields
        if (value === null || value === undefined)
            return false;
        // Include all eager save connections
        if (model.getRelations().has(fieldName)) {
            // We never add relations to filters.
            if (forFilter)
                return false;
            var relation = model.getRelations().get(fieldName);
            var related = model_1.default.getRelatedModel(relation);
            if (related && model.shouldEagerSaveRelation(fieldName, relation, related))
                return true;
            // All other relations are skipped
            return false;
        }
        // Everything else is ok
        return true;
    };
    /**
     * Registers a record for recursion detection.
     * @param {Map<string, Array<string>>} records Map of IDs.
     * @param {ORMModel} record The record to register.
     */
    Transformer.addRecordForRecursionDetection = function (records, record) {
        var context = context_1.default.getInstance();
        if (!record) {
            context.logger.warn("Trying to add invalid record", record, "to recursion detection");
            return;
        }
        if (!record.$self) {
            context.logger.warn("Seems like you're using non-model classes with plugin graphql. You shouldn't do that.");
            return;
        }
        var model = context.getModel(record.$self().entity);
        var ids = records.get(model.singularName) || [];
        ids.push(record.$id);
        records.set(model.singularName, ids);
    };
    /**
     * Detects recursions.
     * @param {Map<string, Array<string>>} records Map of IDs.
     * @param {ORMModel} record The record to check.
     * @return {boolean} true when the record is already included in the records.
     */
    Transformer.isRecursion = function (records, record) {
        if (!record)
            return false;
        if (!record.$self) {
            context_1.default.getInstance().logger.warn("Seems like you're using non-model classes with plugin graphql. You shouldn't do that.");
            return false;
        }
        var model = context_1.default.getInstance().getModel(record.$self().entity);
        var ids = records.get(model.singularName) || [];
        return ids.includes(record.$id);
    };
    return Transformer;
}());
exports.default = Transformer;
//# sourceMappingURL=transformer.js.map